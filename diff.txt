diff --git a/ledger-app/Makefile b/ledger-app/Makefile
index 765e685..b7bb1ff 100755
--- a/ledger-app/Makefile
+++ b/ledger-app/Makefile
@@ -20,7 +20,7 @@ $(error Environment variable BOLOS_SDK is not set)
 endif
 include $(BOLOS_SDK)/Makefile.defines
 
-DEFINES_LIB = USE_LIB_ETHEREUM
+#DEFINES_LIB = USE_LIB_ETHEREUM
 APP_LOAD_PARAMS= --curve secp256k1 $(COMMON_LOAD_PARAMS)
 # Allow the app to use path 45 for multi-sig (see BIP45).
 APP_LOAD_PARAMS += --path "45'"
@@ -32,7 +32,7 @@ APPVERSION=$(APPVERSION_M).$(APPVERSION_N).$(APPVERSION_P)
 APP_LOAD_FLAGS= --appFlags 0x240 --dep Ethereum:$(APPVERSION)
 
 ifeq ($(CHAIN),)
-CHAIN=ethereum
+CHAIN=celo
 endif
 
 ifeq ($(CHAIN),ethereum)
@@ -42,6 +42,10 @@ DEFINES += CHAINID_UPCASE=\"ETHEREUM\" CHAINID_COINNAME=\"ETH\" CHAIN_KIND=CHAIN
 APPNAME = "Ethereum"
 DEFINES_LIB=
 APP_LOAD_FLAGS=--appFlags 0xa40
+else ifeq ($(CHAIN), celo)
+APP_LOAD_PARAMS += --path "44'/52752'"
+DEFINES += CHAINID_UPCASE=\"CELO\" CHAINID_COINNAME=\"cGLD\" CHAIN_KIND=CHAIN_KIND_CELO CHAIN_ID=200110
+APPNAME = "Celo"
 else ifeq ($(CHAIN),ellaism)
 APP_LOAD_PARAMS += --path "44'/163'"
 DEFINES += CHAINID_UPCASE=\"ELLA\" CHAINID_COINNAME=\"ELLA\" CHAIN_KIND=CHAIN_KIND_ELLAISM CHAIN_ID=64
diff --git a/ledger-app/src/chainConfig.h b/ledger-app/src/chainConfig.h
index fe614dc..d3780a7 100644
--- a/ledger-app/src/chainConfig.h
+++ b/ledger-app/src/chainConfig.h
@@ -25,6 +25,7 @@
 typedef enum chain_kind_e {
 	CHAIN_KIND_ETHEREUM,
 	CHAIN_KIND_ETHEREUM_CLASSIC,
+	CHAIN_KIND_CELO,
 	CHAIN_KIND_EXPANSE,
 	CHAIN_KIND_POA,
 	CHAIN_KIND_RSK,
diff --git a/ledger-app/src/main.c b/ledger-app/src/main.c
index 87c559d..29a8305 100644
--- a/ledger-app/src/main.c
+++ b/ledger-app/src/main.c
@@ -153,7 +153,7 @@ volatile bool currentTokenSet;
 
 bagl_element_t tmp_element;
 
-#ifdef TARGET_NANOX
+//#ifdef TARGET_NANOX
 #include "ux.h"
 ux_state_t G_ux;
 bolos_ux_params_t G_ux_params;
@@ -174,8 +174,10 @@ typedef struct internalStorage_t {
 
 typedef struct strData_t {
     char fullAddress[43];
+    char fullGatewayAddress[43];
     char fullAmount[50];
     char maxFee[50];
+    char gatewayFee[50];
 } strData_t;
 
 typedef struct strDataTmp_t {
@@ -296,6 +298,7 @@ void menu_settings_details_change(unsigned int enabled) {
 // show the currently activated entry
 void menu_settings_data_init(unsigned int ignored) {
   UNUSED(ignored);
+  int x = 4;
   UX_MENU_DISPLAY(N_storage.dataAllowed?1:0, menu_settings_data, NULL);
 }
 
@@ -804,6 +807,14 @@ const bagl_element_t ui_approval_nanos[] = {
   {{BAGL_LABELINE                       , 0x05,   0,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, "Maximum fees", 0, 0, 0, NULL, NULL, NULL },
   {{BAGL_LABELINE                       , 0x05,  23,  26,  82,  12, 0x80|10, 0, 0  , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 26  }, (char*)strings.common.maxFee, 0, 0, 0, NULL, NULL, NULL },
 
+  {{BAGL_LABELINE, 0x06, 0, 12, 128, 32, 0, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px | BAGL_FONT_ALIGNMENT_CENTER, 0}, "No Gateway Fee", 0, 0, 0, NULL, NULL, NULL},
+  {{BAGL_LABELINE, 0x06, 23, 26, 82, 12, 0, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px | BAGL_FONT_ALIGNMENT_CENTER, 0}, "", 0, 0, 0, NULL, NULL, NULL},
+  
+  {{BAGL_LABELINE                       , 0x07,   0,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, "Gateway Fee", 0, 0, 0, NULL, NULL, NULL },
+  {{BAGL_LABELINE                       , 0x07,  23,  26,  82,  12, 0x80|10, 0, 0  , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 26  }, (char*)strings.common.maxFee, 0, 0, 0, NULL, NULL, NULL },
+  
+  {{BAGL_LABELINE                       , 0x08,   0,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, "Gateway Fee Addr", 0, 0, 0, NULL, NULL, NULL },
+  {{BAGL_LABELINE                       , 0x08,  23,  26,  82,  12, 0x80|10, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 50   }, (char*)strings.common.fullGatewayAddress, 0, 0, 0, NULL, NULL, NULL },
 };
 
 unsigned int ui_approval_prepro(const bagl_element_t* element) {
@@ -833,6 +844,20 @@ unsigned int ui_approval_prepro(const bagl_element_t* element) {
           case 5:
             UX_CALLBACK_SET_INTERVAL(MAX(3000, 1000+bagl_label_roundtrip_duration_ms(element, 7)));
             break;
+	  case 6:
+	    if (tmpContent.txContent.gatewayDestinationLength == 0) { 
+              UX_CALLBACK_SET_INTERVAL(3000);
+            }
+            else {
+              display = 0;
+              ux_step++; // display the next step
+            }
+          case 7:
+            UX_CALLBACK_SET_INTERVAL(MAX(3000, 1000+bagl_label_roundtrip_duration_ms(element, 7)));
+            break;
+          case 8:
+            UX_CALLBACK_SET_INTERVAL(MAX(3000, 1000+bagl_label_roundtrip_duration_ms(element, 7)));
+            break;
           }
         }
     }
@@ -1777,7 +1802,7 @@ uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
     }
 }
 
-tokenDefinition_t* getKnownToken() {
+tokenDefinition_t* getKnownToken(char *tokenAddr) {
     tokenDefinition_t *currentToken = NULL;
 #ifdef HAVE_TOKENS_LIST
     uint32_t numTokens = 0;
@@ -1792,6 +1817,9 @@ tokenDefinition_t* getKnownToken() {
         case CHAIN_KIND_ETHEREUM_CLASSIC:
             numTokens = NUM_TOKENS_ETHEREUM_CLASSIC;
             break;
+        case CHAIN_KIND_CELO:
+	    numTokens = NUM_TOKENS_CELO;
+	    break;
         case CHAIN_KIND_PIRL:
             numTokens = NUM_TOKENS_PIRL;
             break;
@@ -1858,6 +1886,9 @@ tokenDefinition_t* getKnownToken() {
             case CHAIN_KIND_AKROMA:
                 currentToken = (tokenDefinition_t *)PIC(&TOKENS_AKROMA[i]);
                 break;
+            case CHAIN_KIND_CELO:
+         	currentToken = (tokenDefinition_t *)PIC(&TOKENS_CELO[i]);		
+		break;
             case CHAIN_KIND_ETHEREUM:
                 currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHEREUM[i]);
                 break;
@@ -1925,13 +1956,13 @@ tokenDefinition_t* getKnownToken() {
                 currentToken = (tokenDefinition_t *)PIC(&TOKENS_TOBALABA[i]);
                 break;
         }
-        if (os_memcmp(currentToken->address, tmpContent.txContent.destination, 20) == 0) {
+        if (os_memcmp(currentToken->address, tokenAddr, 20) == 0) {
             return currentToken;
         }
     }
 #endif
 
-    if ((currentTokenSet || tokenProvisioned) && (os_memcmp(tmpCtx.transactionContext.currentToken.address, tmpContent.txContent.destination, 20) == 0)) {
+    if ((currentTokenSet || tokenProvisioned) && (os_memcmp(tmpCtx.transactionContext.currentToken.address, tokenAddr, 20) == 0)) {
       currentTokenSet = false;
       return &tmpCtx.transactionContext.currentToken;
     }
@@ -1957,7 +1988,7 @@ customStatus_e customProcessor(txContext_t *context) {
             tokenProvisioned =
                 (context->currentFieldLength == sizeof(dataContext.tokenContext.data)) &&
                 (os_memcmp(context->workBuffer, TOKEN_TRANSFER_ID, 4) == 0) &&
-                (getKnownToken() != NULL);
+                (getKnownToken(tmpContent.txContent.destination) != NULL);
         }
         if (tokenProvisioned) {
             if (context->currentFieldPos < context->currentFieldLength) {
@@ -2140,11 +2171,20 @@ void finalizeParsing(bool direct) {
   uint256_t gasPrice, startGas, uint256;
   uint32_t i;
   uint8_t address[41];
+  uint8_t gatewayAddress[41];
   uint8_t decimals = WEI_TO_ETHER;
+  uint8_t feeDecimals = WEI_TO_ETHER;
   uint8_t *ticker = (uint8_t *)PIC(chainConfig->coinName);
   uint8_t *feeTicker = (uint8_t *)PIC(chainConfig->coinName);
   uint8_t tickerOffset = 0;
 
+  // Display correct currency if fee currency field sent
+  if (tmpContent.txContent.feeCurrencyLength != 0) {
+    tokenDefinition_t *feeCurrencyToken = getKnownToken(tmpContent.txContent.feeCurrency);
+    feeTicker = feeCurrencyToken->ticker;
+    feeDecimals = feeCurrencyToken->decimals;
+  }
+
   // Verify the chain
   if (chainConfig->chainId != 0) {
     uint32_t v = getV(&tmpContent.txContent);
@@ -2164,7 +2204,7 @@ void finalizeParsing(bool direct) {
   cx_hash((cx_hash_t *)&sha3, CX_LAST, tmpCtx.transactionContext.hash, 0, tmpCtx.transactionContext.hash);
     // If there is a token to process, check if it is well known
     if (tokenProvisioned) {
-        tokenDefinition_t *currentToken = getKnownToken();
+        tokenDefinition_t *currentToken = getKnownToken(tmpContent.txContent.destination);
         if (currentToken != NULL) {
             dataPresent = false;
             decimals = currentToken->decimals;
@@ -2210,6 +2250,14 @@ void finalizeParsing(bool direct) {
     os_memmove((void*)addressSummary, CONTRACT_ADDRESS, sizeof(CONTRACT_ADDRESS));
     strcpy(strings.common.fullAddress, "Contract");
   }
+  // Add gateway fee recipient address
+  if (tmpContent.txContent.gatewayDestinationLength != 0) {
+    getEthAddressStringFromBinary(tmpContent.txContent.gatewayDestination, gatewayAddress, &sha3);
+    strings.common.fullGatewayAddress[0] = '0';
+    strings.common.fullGatewayAddress[1] = 'x';
+    os_memmove((unsigned char *)strings.common.fullGatewayAddress+2, gatewayAddress, 40);
+    strings.common.fullGatewayAddress[42] = '\0';
+  }
   // Add amount in ethers or tokens
   convertUint256BE(tmpContent.txContent.value.value, tmpContent.txContent.value.length, &uint256);
   tostring256(&uint256, 10, (char *)(G_io_apdu_buffer + 100), 100);
@@ -2229,6 +2277,25 @@ void finalizeParsing(bool direct) {
         i++;
     }
   strings.common.fullAmount[tickerOffset + i] = '\0';
+  // Add gateway fee
+  convertUint256BE(tmpContent.txContent.gatewayFee.value, tmpContent.txContent.gatewayFee.length, &uint256);
+  tostring256(&uint256, 10, (char *)(G_io_apdu_buffer + 100), 100);
+  i = 0;
+  while (G_io_apdu_buffer[100 + i]) {
+    i++;
+  }
+  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, feeDecimals);
+  i = 0;
+    tickerOffset = 0;
+    while (feeTicker[tickerOffset]) {
+        strings.common.gatewayFee[tickerOffset] = feeTicker[tickerOffset];
+        tickerOffset++;
+    }
+    while (G_io_apdu_buffer[i]) {
+        strings.common.gatewayFee[tickerOffset + i] = G_io_apdu_buffer[i];
+        i++;
+    }
+  strings.common.gatewayFee[tickerOffset + i] = '\0';
   // Compute maximum fee
   convertUint256BE(tmpContent.txContent.gasprice.value, tmpContent.txContent.gasprice.length, &gasPrice);
   convertUint256BE(tmpContent.txContent.startgas.value, tmpContent.txContent.startgas.length, &startGas);
@@ -2238,7 +2305,7 @@ void finalizeParsing(bool direct) {
   while (G_io_apdu_buffer[100 + i]) {
     i++;
   }
-  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, WEI_TO_ETHER);
+  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, feeDecimals);
   i = 0;
   tickerOffset=0;
   while (feeTicker[tickerOffset]) {
@@ -2259,7 +2326,13 @@ void finalizeParsing(bool direct) {
   ui_approval_transaction_blue_init();
 #elif defined(TARGET_NANOS)
   ux_step = 0;
-  ux_step_count = 5;
+  // only display gateway fields if present
+  if (tmpContent.txContent.gatewayDestinationLength != 0) {
+    ux_step_count = 8;
+  }
+  else {
+    ux_step_count = 6;
+  }
   UX_DISPLAY(ui_approval_nanos, ui_approval_prepro);
 #elif defined(TARGET_NANOX)
   ux_flow_init(0,
diff --git a/ledger-app/src/tokens.c b/ledger-app/src/tokens.c
index 5b458f6..ba1a7fe 100644
--- a/ledger-app/src/tokens.c
+++ b/ledger-app/src/tokens.c
@@ -21,6 +21,8 @@
 
 const tokenDefinition_t const TOKENS_AKROMA[NUM_TOKENS_AKROMA] = {};
 
+const tokenDefinition_t const TOKENS_CELO[NUM_TOKENS_CELO] = {{{0x09, 0x55, 0x31, 0xc4, 0xA9, 0x46, 0x62, 0x3a, 0xAC, 0x5b, 0x3A, 0x98, 0xE4, 0xf0, 0x17, 0x01, 0xaB, 0x25, 0xA8, 0xE6}, "cUSD ", 18},};
+
 const tokenDefinition_t const TOKENS_ETHEREUM[NUM_TOKENS_ETHEREUM] = {
 	{{0x4E,0x84,0xE9,0xe5,0xfb,0x0A,0x97,0x26,0x28,0xCf,0x45,0x68,0xc4,0x03,0x16,0x7E,0xF1,0xD4,0x04,0x31}, "$FFC ", 18},
 	{{0xa0,0x24,0xe8,0x05,0x7e,0xec,0x47,0x4a,0x9b,0x23,0x56,0x83,0x37,0x07,0xdd,0x05,0x79,0xe2,0x6e,0xf3}, "$FYX ", 18},
diff --git a/ledger-app/src/tokens.h b/ledger-app/src/tokens.h
index 488302d..dce5e8a 100644
--- a/ledger-app/src/tokens.h
+++ b/ledger-app/src/tokens.h
@@ -32,6 +32,7 @@ typedef struct tokenDefinition_t {
 #define NUM_TOKENS_ELLAISM 1
 #define NUM_TOKENS_ETHEREUM 1102
 #define NUM_TOKENS_ETHEREUM_CLASSIC 4
+#define NUM_TOKENS_CELO 1
 #define NUM_TOKENS_ETHERSOCIAL 0
 #define NUM_TOKENS_ETHER1 0
 #define NUM_TOKENS_PIRL 0
@@ -56,6 +57,7 @@ extern tokenDefinition_t const TOKENS_AKROMA[NUM_TOKENS_AKROMA];
 extern tokenDefinition_t const TOKENS_ELLAISM[NUM_TOKENS_ELLAISM];
 extern tokenDefinition_t const TOKENS_ETHEREUM[NUM_TOKENS_ETHEREUM];
 extern tokenDefinition_t const TOKENS_ETHEREUM_CLASSIC[NUM_TOKENS_ETHEREUM_CLASSIC];
+extern tokenDefinition_t const TOKENS_CELO[NUM_TOKENS_CELO];
 extern tokenDefinition_t const TOKENS_ETHERSOCIAL[NUM_TOKENS_ETHERSOCIAL];
 extern tokenDefinition_t const TOKENS_ETHER1[NUM_TOKENS_ETHER1];
 extern tokenDefinition_t const TOKENS_PIRL[NUM_TOKENS_PIRL];
diff --git a/ledger-app/src_common/ethUstream.c b/ledger-app/src_common/ethUstream.c
index 09e5de6..3aa539c 100644
--- a/ledger-app/src_common/ethUstream.c
+++ b/ledger-app/src_common/ethUstream.c
@@ -182,6 +182,31 @@ static void processGasprice(txContext_t *context) {
     }
 }
 
+static void processGatewayFee(txContext_t *context) {
+    if (context->currentFieldIsList) {
+        PRINTF("Invalid type for RLP_GATEWAYFEE\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldLength > MAX_INT256) {
+        PRINTF("Invalid length for RLP_GATEWAYFEE\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldPos < context->currentFieldLength) {
+        uint32_t copySize =
+            (context->commandLength <
+                     ((context->currentFieldLength - context->currentFieldPos))
+                 ? context->commandLength
+                 : context->currentFieldLength - context->currentFieldPos);
+        copyTxData(context,
+                   context->content->gatewayFee.value + context->currentFieldPos, 
+                   copySize);
+    }
+    if (context->currentFieldPos == context->currentFieldLength) {
+        context->content->gatewayFee.length = context->currentFieldLength;
+        context->currentField++;
+        context->processingField = false;
+    }
+}
 static void processValue(txContext_t *context) {
     if (context->currentFieldIsList) {
         PRINTF("Invalid type for RLP_VALUE\n");
@@ -234,6 +259,57 @@ static void processTo(txContext_t *context) {
     }
 }
 
+static void processFeeCurrency(txContext_t *context) {
+    if (context->currentFieldIsList) {
+        PRINTF("Invalid type for RLP_FEECURRENCY\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldLength > MAX_ADDRESS) {
+        PRINTF("Invalid length for RLP_FEECURRENCY\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldPos < context->currentFieldLength) {
+        uint32_t copySize =
+            (context->commandLength <
+                     ((context->currentFieldLength - context->currentFieldPos))
+                 ? context->commandLength
+                 : context->currentFieldLength - context->currentFieldPos);
+        copyTxData(context,
+                   context->content->feeCurrency + context->currentFieldPos, 
+                   copySize);
+    }
+    if (context->currentFieldPos == context->currentFieldLength) {
+	context->content->feeCurrencyLength = context->currentFieldLength;    
+        context->currentField++;
+        context->processingField = false;
+    }
+}
+
+static void processGatewayTo(txContext_t *context) {
+    if (context->currentFieldIsList) {
+        PRINTF("Invalid type for RLP_GATEWAYTO\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldLength > MAX_ADDRESS) {
+        PRINTF("Invalid length for RLP_GATEWAYTO\n");
+        THROW(EXCEPTION);
+    }
+    if (context->currentFieldPos < context->currentFieldLength) {
+        uint32_t copySize =
+            (context->commandLength <
+                     ((context->currentFieldLength - context->currentFieldPos))
+                 ? context->commandLength
+                 : context->currentFieldLength - context->currentFieldPos);
+        copyTxData(context,
+                   context->content->gatewayDestination + context->currentFieldPos,
+                   copySize);
+    }
+    if (context->currentFieldPos == context->currentFieldLength) {
+        context->content->gatewayDestinationLength = context->currentFieldLength;
+        context->currentField++;
+        context->processingField = false;
+    }
+}
 static void processData(txContext_t *context) {
     if (context->currentFieldIsList) {
         PRINTF("Invalid type for RLP_DATA\n");
@@ -384,6 +460,15 @@ static parserStatus_e processTxInternal(txContext_t *context) {
             case TX_RLP_TO:
                 processTo(context);
                 break;
+            case TX_RLP_FEECURRENCY:
+		processFeeCurrency(context);
+		break;
+            case TX_RLP_GATEWAYTO:
+		processGatewayTo(context);
+		break;
+            case TX_RLP_GATEWAYFEE:
+		processGatewayFee(context);
+		break;
             case TX_RLP_DATA:
             case TX_RLP_R:
             case TX_RLP_S:
diff --git a/ledger-app/src_common/ethUstream.h b/ledger-app/src_common/ethUstream.h
index c630596..6904630 100644
--- a/ledger-app/src_common/ethUstream.h
+++ b/ledger-app/src_common/ethUstream.h
@@ -44,6 +44,9 @@ typedef enum rlpTxField_e {
     TX_RLP_NONCE,
     TX_RLP_GASPRICE,
     TX_RLP_STARTGAS,
+    TX_RLP_FEECURRENCY,
+    TX_RLP_GATEWAYTO,
+    TX_RLP_GATEWAYFEE,
     TX_RLP_TO,
     TX_RLP_VALUE,
     TX_RLP_DATA,
@@ -69,8 +72,13 @@ typedef struct txContent_t {
     txInt256_t gasprice;
     txInt256_t startgas;
     txInt256_t value;
+    txInt256_t gatewayFee;
     uint8_t destination[20];
     uint8_t destinationLength;
+    uint8_t gatewayDestination[20];
+    uint8_t gatewayDestinationLength;
+    uint8_t feeCurrency[20];
+    uint8_t feeCurrencyLength;
     uint8_t v[4];
     uint8_t vLength;
 } txContent_t;
@@ -102,4 +110,4 @@ parserStatus_e continueTx(txContext_t *context);
 void copyTxData(txContext_t *context, uint8_t *out, uint32_t length);
 uint8_t readTxByte(txContext_t *context);
 
-#endif /* _ETHUSTREAM_H_ */
\ No newline at end of file
+#endif /* _ETHUSTREAM_H_ */
